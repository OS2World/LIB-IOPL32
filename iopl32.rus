                              D I S C L A I M E R
                             =====================

        Я НИКАКОЙ ОТВЕТСТВЕННОСТИ ЗА ИСПОЛЬЗОВАНИЕ ВАМИ IOPL32 НЕ НЕСУ.
        ОБЕЩАЮ ТОЛЬКО ТО,  ЧТО ВИНЧЕСТЕР ОНА НЕ ТРЕТ,  МОНИТОР НЕ ЖГЕТ,
        WINDOWS НА СОСЕДНЕЙ  ПАРТИШНЕ НЕ  СТИРАЕТ, К ФАЙЛАМ  В КОНЕЦ НЕ
        ПРИПИСЫВАЕТСЯ, OS2KRNL  НЕ ПАТЧИТ.  ВСЕ  ИСХОДНИКИ ПРИЛАГАЮТСЯ,
        ТАК ЧТО ЕСЛИ ВДРУГ КТО  НЕ ВЕРИТ  МНЕ НА СЛОВО, ТО  ОН ЗАПРОСТО
        МОЖЕТ УБЕДИТЬСЯ ВО ВСЕМ ВЫШЕСКАЗАННОМ САМ.

    *   Данная версия исправлена на предмет одновременного использова-
    *   ния ее  несколькими программами.  Предыдущая версия  содержала
    *   ошибку в результате которой портился стек тех программ, в про-
    *   цессе  работы  которых другая[ие]  программа[ы] "вклинивалась"
    *   между вызовами функций enterIOPL32() и leaveIOPL32(),  обраща-
    *   ясь к этим же функциям данной библиотеки.

        Библиотека IOPL32.DLL  предназначена для  тех, кому  необходим
    доступ к  сегментам с  привилегией IOPL  из 32-х  битных программ.
    Безусловно, что это было  решаемо и раньше путем  организации т.н.
    Thunks из 32-х  битного сегмента кольца  3 в 16-ти  битный сегмент
    кольца 3 и  последующим дальним вызовом  процедуры в другом  16-ти
    битном  сегменте  кольца  2,  обладающем  уровнем  IOPL, но это не
    всегда удобно по нескольким причинам, в частности:

        1) пользователи  Watcom   C/C++  вынуждены  использовать   для
           линковки  не  WLINK.EXE,  а  LINK386.EXE  в  силу того, что
           первый с  версии 9.5  (более ранней  я не  видел) так  и не
           научился  создавать  корректные  CallGates  для вызова IOPL
           процедур,  что  приводит  к  трапу  в  программе,   которая
           пытается их вызвать.

        2) вероятность того, что  при конвертации FLAT адреса  в адрес
           SEG:OFS при  передаче оного  из 32-х  битного кода  в 16-ти
           битный он попадет  на границу сегмента  мала, но она  есть.
           Это  опять  таки  приводит  к  трапу  во  время  выполнения
           программы.

        3) Thunk'и  вносят довольно  приличный overhead  при частом их
           использовании, например, в цикле.

        Посему  мною  для  себя  была  написана библиотека IOPL32.DLL,
    помогающая решить данные проблемы. Так она была написана для  себя
    и  первоначально  не  предполагалось   выносить  ее  "на   широкую
    публику", то просьба не пинать за довольно скудный  интерфейс и за
    стиль написания :-)

        Интерфейс IOPL32 прост. Существует всего три функции:

                int getCurrentRing(void);
                int enterIOPL32(void);
                int leaveIOPL32(void);

        getCurrentRing(),  как  не  трудно  догадаться  из   названия,
    возвращает номер  кольца, в  котором  в  данное время  выполняется
    программа. Для user level это будет 3, для IOPL level это будет 2.

        enterIOPL32() пытается переключиться  в 32-х битный  сегмент с
    привилегиями ввода/вывода. Она возвращает 0  при успехе и -1   при
    ошибке. Функция сама следит за  тем, из какого кольца она  вызвана
    и возвращает 0 при попытке вызвать ее из кольца 2.

        leaveIOPL32()  осуществляет  операцию,  обратную  той, которую
    делает enterIOPL32(). То есть  она переключает кодовый сегмент  из
    кольца  2  обратно  в  кольцо  3. Возвращаемые значения аналогичны
    enterIOPL32().

        Вместе с  IOPL32.DLL в  данном архиве  лежит TESTIOPL.CPP  для
    тестирования  данной  библиотеки.  Единственное,  что он делает --
    пытается  издать  мерзкий  звук  на  спикере, манипулируя им через
    порт 0x61.  TEST_ICC.EXE скомпилирован  при помощи  Visual Age C++
    3.0  с  патчами  Level  8,  TEST_WPP.EXE  скомпилирован при помощи
    Watcom C/C++ 10.5 с патчами Level B. Соответственно мэйкфайлы  для
    них называются TESTIOPL.ICC и TESTIOPL.WPP

        Обо всех ошибках и пожеланиях можно сообщать по адресам:

                Fido  : 2:5020/620, Rinat Sadretdinow
                e-mail: rhs@uc.ru

        Да, чуть не  забыл. Вы можете  делать с этой  библиотекой все,
    что   угодно,    включая   модификацию    кода,    переименование,
    распечатывание с последующим сжиганием, etc.

            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !!!                                            !!!
            !!! ВСЕ, КРОМЕ ПОРТИРОВАНИЯ ЕЕ ПОД НЕНАВИСТНЫЙ !!!
            !!! ВСЕМУ ПРОГРЕССИВНОМУ  ЧЕЛОВЕЧЕСТВУ WINDOWS !!!
            !!!                                            !!!
            !!!                    :-)                     !!!
            !!!                                            !!!
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        Если Вы исправите какие-нибудь мои ошибки или добавите  в биб-
    лиотеку какие-нибудь новые функции, то не сочтите за  труд выслать
    мне Вашу версию библиотеки.

        Отдельная  благодарность  Сергею  Зефирову,  выведшему меня из
    трех сосен,  в которых  я плутал  часа два.  Все-таки режим  IDEAL
    расхолаживает и  заставляет забывать  прописные истины,  о которых
    все время вынуждены помнить те аскеты, кто пишет в режиме MASM.
